# 笔记

## 嵌入式系统

1. hex、bin文件区别

    hex文件包含地址信息。在用ISP方式烧写程序时，我们都有这样的经验：1)选择单片机型号；2)选择串口号；3)设置波特率(或者默认)；4)选择下载的文件；5)点击下载按钮下载。如下图所示。经过这几步后，程序下载工作就完成了，在以上的步骤中我们并没有选择要把程序下载到单片机的哪块内存中，即不需要设置地址。**因为HEX文件内部的信息已经包括了地址**。而烧写BIN文件的时候，用户是一定需要指定地址信息的。

1. 内核空间、用户空间

    对 32 位操作系统而言，它的寻址空间（虚拟地址空间，或叫线性地址空间）为 4G（2的32次方）。也就是说一个进程的最大地址空间为 4G。操作系统的核心是内核(kernel)，它独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证内核的安全，现在的操作系统一般都强制用户进程不能直接操作内核。具体的实现方式基本都是由操作系统将虚拟地址空间划分为两部分，一部分为内核空间，另一部分为用户空间。针对 Linux 操作系统而言，最高的 1G 字节(从虚拟地址 0xC0000000 到 0xFFFFFFFF)由内核使用，称为内核空间。而较低的 3G 字节(从虚拟地址 0x00000000 到 0xBFFFFFFF)由各个进程使用，称为用户空间。

1. 嵌入式（系统）理解？

    嵌入式系统有别于通用计算机（PC），嵌入式系统强调以**应用**为中心，以计算机技术为基础，软硬件可配置（需要什么功能就应该添加什么硬件以及实现相关软件驱动、应用，比如电饭煲温度调控），对功能、可靠性、成本、体积、功耗有严格约束的专用计算机（只适用于某种特定场景的应用，相较于PC体积更小、功耗较小，对实时性、可靠性要求更高）。（实时性：wxworks导弹发射）

    一般的嵌入式系统没有用到操作系统，只是由一个单个程序实现整个控制逻辑（通俗讲就是在主函数的一个while循环里面轮询地执行整个功能），比如51单片机。当然当这个嵌入式处理器具有中断功能时，比如STM32，便可实现以中断触发的前后台处理模式，避免了轮询模式对CPU资源造成的浪费（每次对每个外设都要询问一便，有时候有些外设时不工作的；有些外设速度快，已经准备好被系统读取，但是由于轮询一定要先询问完前面的外设才能轮到这个外设，降低了实时响应性），能够协调各种外设间的速度差异，提高系统的工作效率。当然有些情形下嵌入式系统用到了操作系统会让整个系统更加合适一些。就我个人项目开发经历而言，移植了操作系统后开发难度降低了很多，整个工程的结构看着也很清晰、很舒适。比如我又两个任务，一个需要一秒执行依次，一个需要三秒执行一次。如果没有操作系统，那么我一般就会用到两个定时器，一个定时器中断一秒触发一次、另一个三秒，并将这两个任务要做的事情分别放到两个中断处理函数里面就行。但是有操作系统就不一样了，首先不需要自己实现延时函数（delay.c），比如ucosii就有提供OSTimeDly()等一系列api，我们只要配置好系统时钟中断就可以了。其次，要实现两个任务，只要调用OSTaskCreate()建立两个任务，然后再两个任务函数里面的while()循环里面一个delay1秒、一个3秒就行。如果还要增加一个任务，只要再OSTaskCreate就行，不用再使用额外的定时器。虽然在任务调度、上下文切换的时候操作系统会消耗一点CPU资源，但是优秀的实时调度算法可以很好地克服这些缺点，比如ucosii的优先级位图法。

    所以我现在做的四轴项目正是在体验、深入了解嵌入式系统这么一个过程。

1. OSTaskCreate做的事情

    首先创建任务时会指定一个优先级，ucosii一般有64个优先级，一开始程序会检查该优先级是否已经被其他任务占用，如果占用则直接退出创建任务。

    若没有其他任务占用，然后就会进行任务堆栈初始化以及任务TCB初始化。操作系统在初始化时会创建64个空的任务TCB结构体，TCB结构体包括栈顶指针、延时数、状态、优先级等变量，TCB初始化时会对他们赋值。

    TCB初始化完成后，再判断操作系统是否正在运行，如果在运行则直接进行任务调度，从就绪队列中找到最高优先级任务执行。如果操作系统没在运行，则退出OSTaskCreate，完成任务的创建。

1. 优先级位图法

    当需要从就绪队列找出最高优先级任务时则用到了优先级位图法。因为如果采用遍历就绪队列中所有TCB的话时间复杂度时O(n)，这是个不确定的量，依赖于当前就绪队列任务数。为了做到实时性，采用牺牲空间换取时间的方法实现了时间复杂度O(1)。OSRdyGrp、OSRdyTbl[]表示哪些优先级的任务就绪

    * 使任务进入就绪队列：

        ```c
        OSRdyGrp |= ptcb->OSTCBBitY;
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
        ```

    * 从就绪队列中找出最高优先级：

        ```c
        y = OSUnMapTbl[OSRdyGrp];
        OSPrioHighRdy = (y<<3) + OSUnMapTbl[OSRdyTbl[y]];
        ```

1. Linux基本操作？

    文件查找、删除、复制、移动、修改；gcc命令；

1. git基本操作？

    1. *基本操作*

        建立git仓库：git init

        复制远程： git clone ssh://user@domain.com/repo.git

        添加远程仓库: git remote add origin xxxxx.git

        添加文件到缓存区： git add [files]

        提交commit： git commit -m "xxx"

        提交到远程仓库： git push origin master

        拉取远程仓库文件： git pull

    1. *分支管理*

        添加分支： git checkout -b [newbranch]

        删除分支： git branch -d [branch]

        切换分支： git checkout [branch]

        合并分支： git merge [branch]

    1. 版本回退：

        回退到指定版本： git reset --hard [commitid]

1. C语言掌握程度？

    指针大小：32机器上四个字节，64位机器上八个字节

1. arm汇编作用？

    直接操作处理器的寄存器，任务上下文切换需要对处理器的寄存器进行保存和恢复，所以要用到汇编

1. Altium Designer掌握程度？

    能设计元器件封装并绘制原理图、PCB板

1. 逻辑分析仪怎么用？

    分析一段时间的方波时序

1. CAN总线？

    CAN 总线是一个广播类型的总线，所以任何在总线上的节点都可以监听总线上传输的数据。也就是说总线上的传输不是点到点的，而是一点对多点的传输，这里多点的意思是总线上所有的节点。

1. X86、arm处理器体系结构？

1. Java、C++特性？

1. makefile?

    makefile就像一个Shell脚本一样

1. CPSR寄存器

    7:0: 控制位，其中[4:0]位为模式位（用户、快中断、中断、管理、中止、未定义、系统），[7]位为IRQ中断标志，[6]FIQ中断标志，[5]工作状态位：thumb、ARM状态

    27:8:保留

    31:28:由高到低分别为N(负数位)、Z(零位)、C(借位位)、O(溢出位)

1. B、BL、BLX

    B：直接跳转

    BL：跳转前将PC保存在LR

    BX:跳转时切换状态,最低位为1切换成thumb状态,最低为为0切换成ARM状态(ARM寻址的地址总是2的倍数,如GPIOA的DATA寄存器地址为0x40004000,GPIOA的ODR寄存器地址为0x4000450C,它们的最低位都为0)

1. thumb、ARM、thumb-2

    * ARM状态:arm处理器工作于**32位**指令的状态，所有指令均为32位

    * thumb状态:arm执行**16位**指令的状态，即16位状态

    * thumb-2状态:这个状态是ARM7版本的ARM处理器所具有的新的状态，新的thumb-2内核技术**兼有16位及32位指令**，实现了更高的性能，更有效的功耗及更少地占用内存。总的来说，感觉这个状态除了兼有arm和thumb的优点外，还在这两种状态上有所提升，优化。

1. ucosii 任务调度、上下文切换？

    任务调度时机：任务创建时、操作系统开始时、任务进入等待队列中、时钟中断结束有任务进入就绪队列。

    上下文切换：保存当前任务现场（PC、R0-R12、LR、CPSR），切换到新任务，恢复新任务堆栈现场

1. NOR flash、NAND flash

    NOR flash：较长时间抹写，但是提供完整寻址与数据总线。

    NAND flash：较快抹写速度，但是只能以块的形式进行读写。

1. cortex-m3m4启动过程

    1. 初始化堆栈指针SP=_initial_sp : STM32的中断向量表规定第一行必须是SP地址，第二行是复位中断入口地址，上电后，CPU首先就会读这两个值，分别存为SP和PC寄存器。上述流程第一行_initial_sp就是SP地址。

    1. 初始化PC指针，令其=Reset_Handler

    1. 初始化中断向量表

    1. 配置系统时钟

    1. 调用C库函数_main(_main是IDE自带的mcu初始化程序，包括堆栈、ram等初始化并自动跳转到main)

1. STM32时钟树、中断机制？

    时钟树配置:HSI、HSE、PLL（HSI、HSE、（/M *N /P））-> SYSCLK

    中断机制：启动文件里面已经建立了中断向量表，向量表里面分别存储了对应中断处理函数的地址

1. PCB电气设计规范？

1. 互补滤波算法？

    陀螺仪积分误差和时间成正比，加速度测出来的角度变化也是随时间成正比，用后者补偿前者。

1. PID？

    “工具人”，根据姿态状况自动进行调节以达到用户设定值。

1. DMA

    DMA提供了一个关于数据的高数传输通道，这个通道不占用CPU的资源。换句话说，通过DMA通道，你在传输大规模数据的时候CPU同时也能够去干其他事。

1. 问面试官问题

    只能工作3个月吗？学院要求有6个月的实习期。房补餐补。

## C与指针

1. int getchar()

    我们用getchar()来读字符，但是EOF是整形的，为了能够当EOF出现时能够正确接收到，一般使用int类型的变量来接收getchar的返回值

1. 链接器

    链接器同时会引入标准C函数库中任何被该程序所用到的函数，而且他可以搜索程序员自己的程序库，将其中需要使用的函数也链接到程序中。

1. 三字母词(trigraphs)

    出现三字母词时编译会出现warnning

1. 枚举类型声明

    typedef enum { OK = 1, ERROR = 0 } Status; 未指明值时默认第一个为0，比前面大一

1. 指针声明

    ```c
    int* a,b,c;//只有a是指针
    ```

1. const

    ```c
    int a[10];

    int * const a;
    a=malloc(10*sizeof(int));
    ```

    两者是一致的，都不能改变指针的值（即指向），但是可以改变指针指向的内存中的值。

1. 链接属性

    链接器链接各文件引用的函数形成可执行文件。external表明不同文件中表示一个实体，internal表明不同实体。

1. static关键字

    当它用于函数定义或者代码块之外的变量声明时。static关键字用于修改标识符的**链接属性**，从external改为internal，但标识符的存储类型和作用域不受影响。用这种方式声明的函数或变量只能在声明他们的源文件中访问。

    当用于代码块内声明变量时，自动类型变为静态类型，但变量的**链接属性**和作用域不受影响。这种变量在程序执行之前创建，直到整个程序结束。

1. 作用域、链接属性和存储类型总结

    | 变量类型 | 声明的位置     | 是否存在于堆栈 | 作用域           | 如果声明为static                                   |
    |:--------:|----------------|----------------|------------------|----------------------------------------------------|
    | 全局     | 所有代码块之外 | 否             | 从声明处到文件尾 | 不允许从其他源文件访问                             |
    | 局部     | 代码块起始处   | 是             | 整个代码块       | 变量不存储于堆栈中，它的值在程序整个执行期一直保持 |
    | 形式参数 | 函数头部       | 是             | 整个函数         | 不允许                                             |

1. 变量作用域

    ```c
    static char b = 2;
    void y(void)
    {
    }
    int a = 1;
    void x(void)
    {
        int c = 3;
        static float d = 4;
    }
    ```

    y函数不能使用a变量。

1. 悬空else

    else语句从属于最靠近他的不完整的if语句

1. switch

    case只定义入口点，如果没有break的话就会一直执行

1. =

    连等表达式最好左值都是同类型，否则会出现数据截断的问题

1. 结合方向

    单目运算符结合方向从左到右

1. 逗号运算符

    整个表达式最终值为最后一个表达式的值。

    ```c
    while(x<10)
        b+=x,
        x+=1;
    ```

1. 1[a]

    1[a]和a[1]意义完全一样，因为会翻译成*(a+1)

1. 数组与指针

    ```c
    char message[]="hello";
    char *message="hello";
    ```

    两者不一样。前者为初始化列表，而后面的则表示一个字符串常量。

1. 结构体变量对齐问题

1. 位段

    减少结构体变量浪费的空间。

1. 联合

    联合的所有成员引用的是内存中的相同位置。

1. 链表

    1. 插入节点

    ```c
    #include <stdio.h>
    #include <stdlib.h>

    typedef union {
        int i;
        float f;
        char c;
    } Value;

    typedef struct NODE {
        struct NODE* next;
        Value value;
    } Node;

    typedef enum {
        TRUE = 1,
        FALSE = 0
    } Status;

    //插入新节点到末尾
    Status InsertNode(Node** ppHead, Value value)
    {
        Node *currNode, *preNode;
        currNode = *ppHead;
        preNode = NULL;

        //遍历到末尾
        while (currNode != NULL) {
            preNode = currNode;
            currNode = currNode->next;
        }

        //申请新节点
        Node* newNode = (Node*)malloc(sizeof(Node));
        newNode->value = value;
        newNode->next = NULL;

        //插入新节点
        if (preNode == NULL)
            *ppHead = newNode;
        else
            preNode->next = newNode;

        return TRUE;
    }

    //反转链表：要想改变指针指向只有传指针的指针
    void ReverseNodeList(Node** ppHead)
    {
        //边界判断
        if (*ppHead == NULL || (*ppHead)->next == NULL)
            return;
        //将链表分为两部分，[1]和[2-n]
        Node* curNode = *ppHead;
        *ppHead = (*ppHead)->next;
        curNode->next = NULL;
        //将[2-n]逆转
        ReverseNodeList(ppHead);
        //将[1]放到逆转后的[2-n]的后面
        Node* nextNode = *ppHead;
        while (nextNode->next != NULL)
            nextNode = nextNode->next;
        nextNode->next = curNode;
        return;
    }

    //合并链表
    Node* MergeNodeList(Node* pHead1, Node* pHead2)
    {
        //边界判断
        if (pHead1 == NULL)
            return pHead2;
        else if (pHead2 == NULL)
            return pHead1;
        //将两链表中较小值取出放入新链表，并将剩下两个链表进行合并后接入新链表后面
        Node* mergeNode = NULL;
        if (pHead1->value.i < pHead2->value.i) {
            mergeNode = pHead1;
            mergeNode->next = MergeNodeList(pHead1->next, pHead2);
        } else {
            mergeNode = pHead2;
            mergeNode->next = MergeNodeList(pHead1, pHead2->next);
        }
        return mergeNode;
    }

    void PrintNodeList(Node* pHead)
    {
        Node* currNode = pHead;
        while (currNode != NULL)
            printf("%d\n", currNode->value.i),
                currNode = currNode->next;
    }

    int main(void)
    {
        int a[5] = { 1, 3, 5, 7, 9 };
        Node* head = NULL;
        for (int i = 0; i < 5; i++)
            InsertNode(&head, *(Value*)(void*)&a[i]);
        int b[5] = { 2, 4, 6, 8, 10 };
        Node* head2 = NULL;
        for (int i = 0; i < 5; i++)
            InsertNode(&head2, *(Value*)(void*)&b[i]);
        Node* mergeNode = MergeNodeList(head, head2);
        PrintNodeList(mergeNode);
        return 0;
    }
    ```

1. 二叉树

    ```cpp
    #include<queue>
    //按层遍历
    void func(BTNode *pRoot){
        //边界判断
        if(pRoot==nullptr)
            return;
        queue<BTNode*> q;
        q.push(pRoot);

        while(q.size()){
            BTNode *currNode=q.front();
            q.pop();
            printf("%d ",currNode->val);
            if(currNode->left!=nullptr)
                q.push(currNode->left);
            if(currNode->right!=nullptr)
                q.push(currNode->right);
        }
    }
    ```

1. 所有指针大小一样吗？

    一样。他们存的都是地址,只是在间接调用时的解读方式不一样。但是进行+、-等运算时，步长是和指针的类型有关的。其次，在不同平台上也不一样，32位机器和64位机器上的不一样，但是同一平台上的一样。

1. 函数指针

    ```c
    //查找节点
    Node *SearchNode(Node *pHead,void const *pValue,int (*compare)(void const *,void const *)){
        Node *currNode=pHead;
        while(currNode!=NULL){
            if(compare(&currNode->value,pValue))
                break;
            currNode=currNode->next;
        }
        return currNode;
    }

    //比较函数
    int compare_int(void const *a,void const *b){
        return *(int*)a==*(int*)b;
    }
    ...

    //调用
    Node *temp=SearchNode(head,&value,compare_int);
    ```

1. 字符串常量

    字符串常量实际上是一个指针。所以

    ```c
    //表示指向y的指针。
    "xyz"+1
    //表示x
    *"xyz"
    //表示z
    "xyz"[2]
    ```

1. 宏函数

    ```c
    //每个参数和总表达式外加括号
    #define ADD(x,y) ((x)+(y))
    //do-while(0)妙用
    #define DELETE_POINTER(p)       \
        do                          \
        {                           \
            if(NULL != p)           \
                delete p;           \
            p = NULL;               \
        }while(0
    ```

1. #include预处理和链接器链接

    #include预处理是将函数**声明**进行包含，类似**传值调用**；而链接器是将函数**实现**进行链接，类似**传址调用**。

1. sizeof

    sizeof是在预处理器完成工作以后而发挥作用的。所以

    ```c
    #if sizeof(int) == 2
        typedef long int32;
    #else
        typedef int int32;
    #endif
    ```

    是错的。

1. 递归与迭代

    如果递归算法在尾部出现，所以我们可以使用迭代更有效地实现这个算法。

1. 泛型

    毫不吃惊的是，用C语言实现泛型是相当困难的，因为它的设计远早于泛型这个概念被提出之时。泛型是面向对象编程语言处理得比较完美的问题之一。

## 程序员的自我修养

1. 内存不够

    * **地址空间不隔离**：所有程序直接访问物理内存，恶意程序很容易修改其他程序内存数据。希望其中一个任务失败也不会影响其他任务。

    * **内存使用效率低**：大量数据换入换出。

    * **运行地址不确定**：

    解决：虚拟地址，映射

1. Linux多线程

    fork:复制当前进程。fork返回新任务的速度非常快，因为fork并不复制原任务的任务空间，而是和原任务一起共享一个**写时复制**的内存空间。

    Linux的fork操作是采取内存共享、写时复制的策略，就是说只有当父子进程一方对一块内存进行写操作时内核会就会复制原来的这块内存到一块新的物理内存上让另一个进程对应的值还是不变。那既然涉及到新的物理内存，为啥他们的地址还是不变？因为打印的地址时**虚拟地址**，就算虚拟地址一样不代表物理地址一样。因为操作系统MMU的存在。

1. 同步和锁

    * 二元信号量：只有两种状态：占用和非占用，适用只能被唯一一个线程独占访问的资源。但是一个线程占据一个锁可以被其他线程释放。

    * 互斥量：于二元信号量很类似，只是一个线程占据一个锁只能由它自己释放。

    * 信号量：一个初始值为N的信号量允许N个线程并发访问。

    * 读写锁：可多读不可多写。

    * 临界区：和互斥量相同性质，但是互斥量在不同进程中式可见的，临界区却只针对本进程。

1. ARM7 ARM9 ARM Cortex M3 M4 有什么区别？

    一般情况下ARM7 Cortex-M3 Cortex-M4可以认为是一类，M3和M4都是针对微控制器（单片机）设计的，一般运行嵌入式操作系统或者不带操作系统。而ARM7更多时候也是作为单片机，比如一些蓝牙芯片是ARM7的。Cortex-M3和M4相比，M4有浮点数运算单元和SIMD指令（DSP）（可以加快一些数学运算的速度），都有功能较强的中断控制器。ARM7架构较老，运算性能和中断性能较差，基本上可以被Cortex-M3和M4完全替代。ARM9一般看到的是应用级处理器，运行Linux或者OpenWRT之类的操作系统。ARM9一般主频会比较高，所以处理速度比大部分微控制器快。ARM9开发相对更加复杂，不过可以用linux下的驱动模块。这些都是处理器的IP核，可以大致相当于CPU的架构。不同厂家用同一款IP核做出来的芯片可能差别很大。具体要看各个厂家的数据手册，整体上性能ARM9>Cortex-M4>Cortex-M3>ARM7。

1. ucosii中的临界区

    * 如果是arm9处理器，里面有个cpsr寄存器，其中第8位为IRQ中断位，如果关闭它那么程序将不会响应所有将关闭所有可屏蔽中断的异常（IRQ中断），但不包括FIQ、NMI、硬件中断等。

        ```c
        OSCPUSaveSR
            MRS     R0,CPSR
            ORR     R1,R0,#0x80//IRQ位置1
            MSR     CPSR_c,R1
            MOV     PC,LR

        OSCPURestoreSR
            MSR     CPSR_c,R0
            MOV     PC,LR
        ```

    * 如果是cortex-m3、m4系列处理器，里面有一个中断屏蔽寄存器PRIMASK，置1后，将关闭所有可屏蔽中断的异常，只剩NMI和硬fault，默认值为0。

        ```c
        OS_CPU_SR_Save
                    MRS     R0,PRIMASK
                    CPSID   I//关中断
                    BX      LR

        OS_CPU_SR_Restore
                    MSR     PRIMASK,R0
                    BX      LR
        ```

## C专家编程

1. NUL、NULL

    一个‘L’的NUL用于结束一个ASCII字符串。两个‘L’的NULL用于表示什么也不指向（空指针）。

1. typedef和#define

    ```c
    //例子一
    #define peach int
    unsigned peach i;//没问题
    ...
    typedef int peach;
    unsigned peach i;//错误

    //例子二
    #define pChar char*
    pChar a,b,c;//只有a是指针
    ...
    typedef char* pChar;
    pChar a,b,c;//都是指针
    ```

1. C语言设计哲学

    所有特性都不需要隐式的运行时支持

1. C++对C语言的改进

    C++允许一个常量整数来定义数组的大小：

    ```c
    //c++中正确，c中错误
    const int size=5;
    int a[size];
    ```
